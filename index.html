<!DOCTYPE html>
<html>
<head>
    <title>CS Student VR World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        canvas {
            display: block;
        }
        
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            z-index: 101;
        }
        
        .start-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div class="ui-overlay">
        <h3>ðŸŽ“ CS Student VR World</h3>
        <p>Click "Enter VR" to start your adventure!</p>
        <p>Features: Animated models, coding elements, and fun interactions</p>
    </div>
    
    <button class="start-button" id="startVR">ðŸš€ Enter VR Experience</button>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Point light for dramatic effect
        const pointLight = new THREE.PointLight(0xff6b6b, 1, 100);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);
        
        // Ground with grid pattern (like coding grid)
        const groundGeometry = new THREE.PlaneGeometry(20, 20, 20, 20);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x2c3e50,
            wireframe: false
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid overlay
        const gridHelper = new THREE.GridHelper(20, 20, 0x34495e, 0x34495e);
        scene.add(gridHelper);
        
        // Animated objects array
        const animatedObjects = [];
        
        // Create floating code blocks
        function createCodeBlock(x, y, z, text) {
            const geometry = new THREE.BoxGeometry(1, 0.1, 0.6);
            const material = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const codeBlock = new THREE.Mesh(geometry, material);
            codeBlock.position.set(x, y, z);
            codeBlock.castShadow = true;
            scene.add(codeBlock);
            animatedObjects.push(codeBlock);
            return codeBlock;
        }
        
        // Create multiple floating code blocks
        createCodeBlock(-3, 2, -3);
        createCodeBlock(3, 1.5, -2);
        createCodeBlock(-1, 3, -4);
        createCodeBlock(2, 2.5, -1);
        
        // Create animated laptop
        function createLaptop() {
            const laptopGroup = new THREE.Group();
            
            // Laptop base
            const baseGeometry = new THREE.BoxGeometry(2, 0.1, 1.5);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            
            // Laptop screen
            const screenGeometry = new THREE.BoxGeometry(2, 1.3, 0.05);
            const screenMaterial = new THREE.MeshPhongMaterial({ color: 0x34495e });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 0.65, -0.7);
            screen.rotation.x = -Math.PI / 6;
            screen.castShadow = true;
            
            // Screen glow
            const screenGlow = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 1.1),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.7 
                })
            );
            screenGlow.position.set(0, 0.65, -0.68);
            screenGlow.rotation.x = -Math.PI / 6;
            
            laptopGroup.add(base);
            laptopGroup.add(screen);
            laptopGroup.add(screenGlow);
            laptopGroup.position.set(0, 0.05, -2);
            
            scene.add(laptopGroup);
            animatedObjects.push(laptopGroup);
            return laptopGroup;
        }
        
        const laptop = createLaptop();
        
        // Create animated robot companion
        function createRobot() {
            const robotGroup = new THREE.Group();
            
            // Robot body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x3498db });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            // Robot head
            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xe74c3c });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.65;
            head.castShadow = true;
            
            // Robot eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 0.75, 0.2);
            rightEye.position.set(0.1, 0.75, 0.2);
            
            // Robot arms
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0xf39c12 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.2, 0);
            rightArm.position.set(0.4, 0.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            rightArm.rotation.z = -Math.PI / 4;
            
            robotGroup.add(body);
            robotGroup.add(head);
            robotGroup.add(leftEye);
            robotGroup.add(rightEye);
            robotGroup.add(leftArm);
            robotGroup.add(rightArm);
            robotGroup.position.set(2, 0.4, -1);
            
            scene.add(robotGroup);
            animatedObjects.push(robotGroup);
            return robotGroup;
        }
        
        const robot = createRobot();
        
        // Create floating mathematical formulas
        function createFloatingFormula(x, y, z, color) {
            const geometry = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const formula = new THREE.Mesh(geometry, material);
            formula.position.set(x, y, z);
            formula.castShadow = true;
            scene.add(formula);
            animatedObjects.push(formula);
            return formula;
        }
        
        // Add multiple floating formulas
        const formulas = [
            createFloatingFormula(-4, 3, -2, 0xff6b6b),
            createFloatingFormula(4, 2.5, -3, 0x4ecdc4),
            createFloatingFormula(-2, 4, -1, 0xffe66d),
            createFloatingFormula(1, 3.5, -4, 0xa8e6cf)
        ];
        
        // Create particle system for coding magic
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 1000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 20;
            positions[i + 1] = Math.random() * 10;
            positions[i + 2] = (Math.random() - 0.5) * 20;
            
            colors[i] = Math.random();
            colors[i + 1] = Math.random();
            colors[i + 2] = Math.random();
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.05,
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        
        // Camera position
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);
        
        // Animation variables
        let time = 0;
        
        // Animation loop
        function animate() {
            time += 0.01;
            
            // Animate code blocks
            animatedObjects.forEach((obj, index) => {
                if (obj.geometry && obj.geometry.type === 'BoxGeometry') {
                    obj.rotation.y += 0.01;
                    obj.position.y += Math.sin(time + index) * 0.005;
                }
            });
            
            // Animate laptop screen glow
            if (laptop.children[2]) {
                laptop.children[2].material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
            }
            
            // Animate robot
            robot.rotation.y += 0.005;
            robot.position.y = 0.4 + Math.sin(time * 2) * 0.1;
            
            // Animate formulas
            formulas.forEach((formula, index) => {
                formula.rotation.x += 0.01;
                formula.rotation.y += 0.015;
                formula.position.y += Math.sin(time * 2 + index) * 0.01;
            });
            
            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time + i) * 0.01;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.001;
            
            // Animate point light
            pointLight.position.x = Math.sin(time) * 3;
            pointLight.position.z = Math.cos(time) * 3;
            
            renderer.render(scene, camera);
        }
        
        // VR setup
        const startButton = document.getElementById('startVR');
        startButton.addEventListener('click', async () => {
            if ('xr' in navigator) {
                try {
                    const session = await navigator.xr.requestSession('immersive-vr', {
                        requiredFeatures: ['local-floor']
                    });
                    renderer.xr.setSession(session);
                    startButton.style.display = 'none';
                    document.querySelector('.ui-overlay').style.display = 'none';
                } catch (error) {
                    console.log('VR not supported or available, running in standard mode');
                    startButton.textContent = 'ðŸ–¥ï¸ Explore Scene';
                    startButton.onclick = () => {
                        startButton.style.display = 'none';
                        document.querySelector('.ui-overlay').style.display = 'none';
                    };
                }
            } else {
                startButton.textContent = 'ðŸ–¥ï¸ Explore Scene';
                startButton.onclick = () => {
                    startButton.style.display = 'none';
                    document.querySelector('.ui-overlay').style.display = 'none';
                };
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse controls for non-VR mode
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            camera.position.x += (mouseX * 2 - camera.position.x) * 0.05;
            camera.position.y += (mouseY * 2 + 2 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        });
        
        // Start animation
        renderer.setAnimationLoop(animate);
    </script>
</body>
</html>
